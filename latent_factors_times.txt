Timer unit: 4.46191e-07 s

Total time: 406.315 s
File: latent_factors.py
Function: matrix_factorization at line 12

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    12                                           @profile
    13                                           def matrix_factorization(user_movie_matrix, dimensions=2, lambda_=10, learning_rate=0.01, max_steps=50, min_error=0.01):
    14                                               """ Matrix Factorization with missing values using gradient descent
    15                                           
    16                                               :param numpy.array user_movie_matrix: input matrix to factorize and from which to learn the latent factor model
    17                                               :param int dimensions: the "free" dimension of the latent factor model
    18                                               :param float lambda_: the regularization parameter
    19                                               :param float learning_rate: the gradient descent learning rate
    20                                               :param int max_steps: the step at which to stop gradient descent
    21                                               :param float min_error: the error at which to stop gradient descent
    22                                               :return: two latent factor models with the shapes M*dimensions and dimensions*N;
    23                                               :rtype: tuple 
    24                                               """
    25         1           11     11.0      0.0      m, n = user_movie_matrix.shape
    26         1          528    528.0      0.0      u = np.random.rand(m, dimensions)
    27         1          937    937.0      0.0      v = np.random.rand(dimensions, n)
    28        11           46      4.2      0.0      for step in xrange(max_steps):
    29                                                   # TODO: determine why the sqrt-decreasing learning rate results in tiny u and v values
    30        10           31      3.1      0.0          learning_rate_decreasing = learning_rate  # / sqrt(step + 1)
    31      9440        24621      2.6      0.0          for i_user in xrange(m):
    32  15870690     47802981      3.0      5.2              for j_movie in xrange(n):
    33                                                           # Only calculate non-missing values
    34  15861260    176791549     11.1     19.4                  if user_movie_matrix[i_user][j_movie] > 0:
    35   1000000     25817994     25.8      2.8                      error = user_movie_matrix[i_user][j_movie] - np.dot(u[i_user, :], v[:, j_movie])
    36                                                               # Gradient descent
    37  11000000     33737316      3.1      3.7                      for dimension in xrange(dimensions):
    38  10000000     65016639      6.5      7.1                          u[i_user][dimension] += learning_rate_decreasing * (2 * error * v[dimension][j_movie] -
    39  10000000     65455205      6.5      7.2                                                                              lambda_ * u[i_user][dimension])
    40  10000000     62499409      6.2      6.9                          v[dimension][j_movie] += learning_rate_decreasing * (2 * error * u[i_user][dimension] -
    41  10000000     65304580      6.5      7.2                                                                               lambda_ * v[dimension][j_movie])
    42        10       260458  26045.8      0.0          u_dot_v = np.dot(u, v)
    43        10          169     16.9      0.0          error_total = 0
    44      9440        24813      2.6      0.0          for i_user in xrange(m):
    45  15870690     47864183      3.0      5.3              for j_movie in xrange(n):
    46  15861260    172838985     10.9     19.0                  if user_movie_matrix[i_user][j_movie] > 0:
    47   1000000     17787507     17.8      2.0                      error_total += (user_movie_matrix[i_user][j_movie] - u_dot_v[i_user, j_movie]) ** 2
    48                                                               # Frobenius norm
    49  11000000     33735808      3.1      3.7                      for dimension in xrange(dimensions):
    50  10000000     95652310      9.6     10.5                          error_total += lambda_ / 2 * (u[i_user][dimension] ** 2 + v[dimension][j_movie] ** 2)
    51        10           37      3.7      0.0          if DEBUG:
    52        10          157     15.7      0.0              spacing = ' ' * (len(str(max_steps)) - len(str(step + 1)))
    53        10           52      5.2      0.0              print ('{}{} steps done, error = {:.3g} (stopping at step {} or error {:.3g})'
    54        10        12205   1220.5      0.0                     .format(spacing, step + 1, error_total, max_steps, min_error))
    55        10          115     11.5      0.0          if error_total < min_error:
    56                                                       break
    57         1            4      4.0      0.0      return u, v

